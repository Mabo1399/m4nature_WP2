method_notes = as.character(input$method_notes)
) %>%
bind_cols(as_tibble(t(methods_wide))) %>%
mutate(across(everything(), as.character))
# Append to results, replacing existing row (match title + year)
res <- results_rv()
res <- res %>%
filter(!(safe_equal_str(title, current()$title) &
safe_equal_int(year, current()$year)))
res <- bind_rows(res, row)
results_rv(res)
write_csv(res, results_path)
showNotification("Included entry saved.", type = "message")
updateTabsetPanel(session, "main_tabs", selected = "tab1")
update_record_choices()
})
}
# =========================
# RUN APP
# =========================
shinyApp(ui, server)
# =========================
# Scoping Review Shiny
# =========================
library(shiny)
library(shinyjs)
library(sortable)
library(readr)
library(dplyr)
library(lubridate)
library(tibble)
library(stringr)
# User Paths, need to be defined manually
file_type <- "scientific"  # set to "overton" or "scientific",
# will account for differential structure of results export files later
data_path <- "/Users/maxbodanowitz/Desktop/wos_results.txt"  # set path
results_path <- "/Users/maxbodanowitz/Desktop/coding_results.csv" # set path, .csv will be created when first using the tool
# Check for file
if(!file.exists(data_path)) stop("Input file not found!")
# some helper functions
# mostly deal with formatting issues that will come up (col type etc.)
`%||%` <- function(x, y) if (is.null(x)) y else x
as_int <- function(x) suppressWarnings(as.integer(x))
get_col <- function(df, col, default = NA_character_) {
if (col %in% names(df)) {
v <- df[[col]]
if (is.list(v)) v <- sapply(v, function(x) paste(x, collapse = "; "))
if (is.factor(v)) v <- as.character(v)
v
} else {
rep(default, nrow(df))
}
}
safe_year <- function(x) {
suppressWarnings({
d <- parse_date_time(x, orders = c("ymd", "dmy", "mdy", "Ymd", "BdY", "dbY"))
})
y <- year(d)
y[is.na(y)] <- suppressWarnings(as.integer(x[is.na(y)]))
y
}
# Load data
if (file_type == "overton") raw_data <- read_csv(data_path, show_col_types = FALSE)
if (file_type == "scientific") raw_data <- read_tsv(data_path, show_col_types = FALSE, quote = "")
# adapt different input data formats to unified format
adapt_overton <- function(df) {
tibble(
source    = "Overton",
raw_id    = get_col(df, "Overton id"),
authors   = get_col(df, "Policy authors"),
year      = safe_year(get_col(df, "Published_on")),
title     = get_col(df, "Title"),
journal   = NA_character_,
publisher = get_col(df, "Source title"),
volume    = NA_character_,
issue     = NA_character_,
pages     = NA_character_,
doi       = NA_character_,
url       = get_col(df, "Document URL"),
abstract  = NA_character_
)
}
adapt_scientific <- function(df) {
BP <- get_col(df, "BP")
EP <- get_col(df, "EP")
pages <- ifelse(!is.na(BP) & !is.na(EP), paste0(BP, "-", EP), NA_character_)
VL <- get_col(df, "VL")
IS <- get_col(df, "IS")
PY <- get_col(df, "PY")
DI <- get_col(df, "DI")
DL <- get_col(df, "DL")
tibble(
source    = "Web of Science",
raw_id    = get_col(df, "UT"),
authors   = get_col(df, "AU"),
year      = suppressWarnings(as.integer(PY)),
title     = get_col(df, "TI"),
journal   = get_col(df, "SO"),
publisher = NA_character_,
volume    = as.character(VL),
issue     = IS,
pages     = pages,
doi       = DI,
url       = DL,
abstract  = get_col(df, "AB")
)
}
records_df <- if (file_type == "overton") adapt_overton(raw_data) else adapt_scientific(raw_data)
# ---- RESULTS SCHEMA ----
expected_cols <- c(
"title","authors","year","included","exclusion_reason",
"literature_type","scale_governance",
"decision_type","policy_stage","participation_level","methods_used",
"challenges","other_benefits","method_notes",
paste0("method_group_", 1:7)
)
if (file.exists(results_path)) {
# Force all columns to character for stability
results_df <- read_csv(results_path, col_types = cols(.default = col_character()))
missing_cols <- setdiff(expected_cols, names(results_df))
if (length(missing_cols) > 0) {
for (mc in missing_cols) results_df[[mc]] <- NA_character_
}
results_df <- results_df %>% select(all_of(expected_cols))
} else {
results_df <- as_tibble(setNames(rep(list(character()), length(expected_cols)), expected_cols))
}
# =========================
# UI
# =========================
ui <- fluidPage(
useShinyjs(),
titlePanel("WP2 REA Tool"),
# CSS to split checkbox lists into two columns
tags$style(HTML("
.two-col .shiny-options-group {
column-count: 2;
-moz-column-count: 2;
-webkit-column-count: 2;
}
/* Optional: tighten spacing */
.two-col .checkbox, .two-col .radio {
margin-top: 4px;
margin-bottom: 4px;
}
")),
sidebarLayout(
sidebarPanel(
selectInput("record", "Select article", choices = NULL),
width = 3
),
mainPanel(
tabsetPanel(
id = "main_tabs",
# TAB 1: Select paper and eligibility
tabPanel(
"1. Eligibility & metadata", value = "tab1",
h4("Citation Info"),
textOutput("title_text"),
textOutput("authors_text"),
textOutput("year_text"),
hr(),
radioButtons(
"included",
"Meets inclusion criteria?",
choices = c("Yes", "No"),
selected = character(0)
),
hr(),
radioButtons(
"literature_type",
"Literature type",
choices = c("Grey literature", "Scientific Literature", "Eklipse/BioAgora"),
selected = character(0)
),
conditionalPanel(
condition = "input.included == 'No'",
textAreaInput("exclusion_reason", "Reason for exclusion", rows = 3),
actionButton("save_entry_tab1", "Save Entry (Not Included)")
)
),
# TAB 2: Investigation attributes
tabPanel(
"2. Investigation attributes", value = "tab2",
div(class = "two-col",
checkboxGroupInput(
"decision_type",
"Type of decision / knowledge need (Pullin et al., 2016) [multi-select]",
choices = c(
"Seeking better understanding of an issue (including predictions and forecasting)",
"Identifying appropriate ways and means of realising certain decisions",
"Improving understanding of possibilities and boundaries for decision-making"
)
)
),
div(class = "two-col",
checkboxGroupInput(
"policy_stage",
"Stage of policy cycle [multi-select]",
choices = c(
"Agenda-Setting",
"Policy Formulation",
"Policy Adoption",
"Policy Implementation",
"Policy Evaluation"
)
)
),
div(class = "two-col",
checkboxGroupInput(
"participation_level",
"Level of participation [multi-select]",
choices = c("Inform", "Involve", "Consult", "Collaborate", "Empower")
)
),
div(class = "two-col",
checkboxGroupInput(
"scale_governance",
"Scale or governance level [multi-select]",
choices = c(
"Community/Local",
"Municipal/City",
"Regional/Subnational",
"National",
"Multinational (e.g., EU)",
"Global"
)
)
)
),
# TAB 3: Methods application
tabPanel(
"3. Methods application", value = "tab3",
div(class = "two-col",
checkboxGroupInput(
"methods_used", "Methods used [multi-select]",
choices = c(
"Bayesian Belief Networks",
"Bow Tie Analysis",
"Causal Criteria Analysis",
"Collaborative Adaptive Management",
"Discourse Analysis",
"Expert Consultation",
"Focus Group(s)",
"Fuzzy Cognitive Mapping",
"Joint Fact-finding",
"Meta-analysis",
"Multi-criteria Decision Analysis",
"Multiple Expert Consultation + Delphi Process",
"Participatory Mapping",
"Nominal Group Technique",
"Non-systematic Literature Review",
"Qualitative Comparative Analysis",
"Rapid Evidence Assessment",
"Scenario Analysis",
"Scoping Review",
"Solution Scanning",
"Structured Decision-making",
"Subject-wide Evidence Synthesis",
"Systematic Map",
"Systematic Review",
"Vote Counting",
"Additional Method used [elaborate]"
)
)
),
hr(),
h4("Organize methods into sequential groups (simultaneous within group)"),
uiOutput("methods_bucket_ui"),
hr(),
div(class = "two-col",
checkboxGroupInput(
"challenges",
"Challenges [multi-select]",
choices = c(
"Participation/logistical (time, recruitment)",
"Evidence/expertise (gaps in expertise)",
"Bias/subjectivity (analytical subjectivity, non-systematic evidence base)",
"Synthesis/integration (complexity of combining heterogeneous inputs)"
)
)
),
textAreaInput("other_benefits", "Other benefits", rows = 3),
textAreaInput("method_notes", "Method notes / additions", rows = 4),
actionButton("save_entry", "Save Entry")
)
)
)
)
)
# =========================
# SERVER
# =========================
server <- function(input, output, session) {
# Reactive value for results (all character columns)
results_rv <- reactiveVal(results_df)
# NA-safe comparisons for title and year
safe_equal_str <- function(a, b) {
a <- ifelse(is.na(a), "", str_trim(a))
b <- ifelse(is.na(b), "", str_trim(b))
a == b
}
safe_equal_int <- function(a, b) {
ai <- as_int(a); bi <- as_int(b)
(is.na(ai) & is.na(bi)) | (!is.na(ai) & !is.na(bi) & ai == bi)
}
# Completion status for a single result row
completion_status <- function(row) {
inc <- row$included
if (is.na(inc) || inc == "") return("ðŸŸ  Not complete")
if (inc == "No") {
reason_ok <- !is.null(row$exclusion_reason) && nzchar(row$exclusion_reason)
if (reason_ok) return("ðŸŸ¢ Done â€“ not included")
return("ðŸŸ  Not complete")
}
if (inc == "Yes") {
# Require literature_type, scale_governance, and at least one selection in each multi-select group
req_ok <- all(
nzchar(row$literature_type %||% ""),
nzchar(row$scale_governance %||% ""),
nzchar(row$decision_type %||% ""),
nzchar(row$policy_stage %||% ""),
nzchar(row$participation_level %||% ""),
nzchar(row$methods_used %||% ""),
nzchar(row$challenges %||% "")
)
if (req_ok) return("ðŸŸ¢ Done")
return("ðŸŸ  Not complete")
}
"ðŸŸ  Not complete"
}
# Update article selector with color-coded status
update_record_choices <- function() {
res <- isolate(results_rv())
choices <- sapply(seq_len(nrow(records_df)), function(i) {
r <- records_df[i, ]
if (nrow(res) > 0) {
res_row <- res %>%
filter(
safe_equal_str(title, r$title) &
safe_equal_int(year, r$year)
)
if (nrow(res_row) == 0) {
status <- "ðŸ”´ Not started"
} else {
status <- completion_status(res_row[1, ])
}
} else {
status <- "ðŸ”´ Not started"
}
paste0(r$year, " â€“ ", r$title, " [", status, "]")
})
updateSelectInput(session, "record", choices = setNames(seq_len(nrow(records_df)), choices))
}
# Initial population
update_record_choices()
# Current record
current <- reactive({
req(input$record)
records_df[as.integer(input$record), ]
})
# Display citation info
output$title_text <- renderText({ paste("Title:", current()$title) })
output$authors_text <- renderText({ paste("Authors:", current()$authors) })
output$year_text <- renderText({ paste("Year:", current()$year) })
# Gate tabs until inclusion is Yes (but allow saving from tab1 when No)
observe({
inc <- input$included
if (is.null(inc) || inc != "Yes") {
updateTabsetPanel(session, "main_tabs", selected = "tab1")
}
})
# Methods buckets (max 7 groups)
output$methods_bucket_ui <- renderUI({
req(input$methods_used)
n_methods <- length(input$methods_used)
n_groups <- min(n_methods, 7)
rank_lists <- lapply(seq_len(n_groups), function(i) {
add_rank_list(
text = paste0("Group ", i),
labels = NULL,
input_id = paste0("group_", i)
)
})
do.call(
bucket_list,
c(
list(
header = "Drag methods into sequential groups (simultaneous within group)",
group_name = "method_groups",
orientation = "horizontal",
add_rank_list(
text = "Available methods",
labels = input$methods_used,
input_id = "methods_source"
)
),
rank_lists
)
)
})
# Prevent navigating to tabs 2/3 until included is Yes
observe({
if (!is.null(input$main_tabs) && input$main_tabs %in% c("tab2", "tab3")) {
if (is.null(input$included) || input$included != "Yes") {
showNotification("You must mark 'Meets inclusion criteria?' as Yes to proceed.", type = "error")
updateTabsetPanel(session, "main_tabs", selected = "tab1")
}
}
})
# Save excluded entry from Tab 1
observeEvent(input$save_entry_tab1, {
req(input$included)
if (input$included != "No") {
showNotification("Use the Tab 3 Save Entry for included records.", type = "warning")
return(NULL)
}
if (is.null(input$exclusion_reason) || input$exclusion_reason == "") {
showNotification("Please provide a reason for exclusion.", type = "error")
return(NULL)
}
empty_groups <- setNames(rep(NA_character_, 7), paste0("method_group_", 1:7))
row <- tibble(
title = as.character(current()$title),
authors = as.character(current()$authors),
year = as.character(current()$year),
included = "No",
exclusion_reason = as.character(input$exclusion_reason),
literature_type = as.character(input$literature_type %||% ""),
scale_governance = NA_character_,
decision_type = NA_character_,
policy_stage = NA_character_,
participation_level = NA_character_,
methods_used = NA_character_,
challenges = NA_character_,
other_benefits = NA_character_,
method_notes = NA_character_
) %>%
bind_cols(as_tibble(t(empty_groups))) %>%
mutate(across(everything(), as.character))
# Append to results, replacing existing row (match title + year)
res <- results_rv()
res <- res %>%
filter(!(safe_equal_str(title, current()$title) &
safe_equal_int(year, current()$year)))
res <- bind_rows(res, row)
results_rv(res)
write_csv(res, results_path)
showNotification("Excluded entry saved.", type = "message")
updateTabsetPanel(session, "main_tabs", selected = "tab1")
update_record_choices()
})
# Save included entry from Tab 3
observeEvent(input$save_entry, {
req(input$included)
if (input$included != "Yes") {
showNotification("Mark inclusion as 'Yes' to save full methods entry, or save as exclusion in Tab 1.", type = "warning")
return(NULL)
}
# Methods grouped wide
methods_wide <- sapply(1:7, function(i) {
g <- input$method_groups[[paste0("group_", i)]]
if (is.null(g) || length(g) == 0) return(NA_character_)
paste(g, collapse = "; ")
})
names(methods_wide) <- paste0("method_group_", 1:7)
# Build row to save (as character columns)
row <- tibble(
title = as.character(current()$title),
authors = as.character(current()$authors),
year = as.character(current()$year),
included = "Yes",
exclusion_reason = NA_character_,
literature_type = as.character(input$literature_type %||% ""),
scale_governance = as.character(input$scale_governance %||% ""),
decision_type = paste(input$decision_type %||% character(), collapse = "; "),
policy_stage = paste(input$policy_stage %||% character(), collapse = "; "),
participation_level = paste(input$participation_level %||% character(), collapse = "; "),
methods_used = paste(input$methods_used %||% character(), collapse = "; "),
challenges = paste(input$challenges %||% character(), collapse = "; "),
other_benefits = as.character(input$other_benefits),
method_notes = as.character(input$method_notes)
) %>%
bind_cols(as_tibble(t(methods_wide))) %>%
mutate(across(everything(), as.character))
# Append to results, replacing existing row (match title + year)
res <- results_rv()
res <- res %>%
filter(!(safe_equal_str(title, current()$title) &
safe_equal_int(year, current()$year)))
res <- bind_rows(res, row)
results_rv(res)
write_csv(res, results_path)
showNotification("Included entry saved.", type = "message")
updateTabsetPanel(session, "main_tabs", selected = "tab1")
update_record_choices()
})
}
# =========================
# RUN APP
# =========================
shinyApp(ui, server)
sessionInfo()
options(renv.config.autoloader.enabled = FALSE)  # keep renv off
install.packages("shinylive")
setwd("/Users/maxbodanowitz/Documents/GitHub/m4nature_WP2")  # adjust if needed
shinylive::export("app", "docs")
options(renv.config.autoloader.enabled = FALSE)  # keep renv off
install.packages("shinylive")
setwd("/Users/maxbodanowitz/Documents/GitHub/m4nature_WP2")  # adjust if needed
shinylive::export("app", "docs")
sessionInfo()
