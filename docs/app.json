[{"name":"app.R","content":"# =========================\n# WP2 REA Tool (Shinylive/WebR-compatible)\n# =========================\n\nlibrary(shiny)\nlibrary(shinyjs)\nlibrary(sortable)\nlibrary(readr)\nlibrary(dplyr)\nlibrary(lubridate)\nlibrary(tibble)\nlibrary(stringr)\nlibrary(jsonlite)\nlibrary(webr)   # for webR-friendly fetch\n\n# ---- CONFIG ----\nGITHUB_USER <- \"Mabo1399\"\nREPO_NAME   <- \"m4nature_WP2\"\nBRANCH      <- \"main\"\n\n# Set the data source type and raw file URL in your repo:\nfile_type   <- \"scientific\"  # \"scientific\" (TSV WoS) or \"overton\" (CSV)\nDATA_URL    <- sprintf(\"https://raw.githubusercontent.com/%s/%s/%s/data/wos_results.txt\",\n                       GITHUB_USER, REPO_NAME, BRANCH)\n\n# Paste your Apps Script Web App URL (ends with /exec); use a CORS proxy if needed\nGS_ENDPOINT <- \"https://script.google.com/macros/s/AKfycbyKEc-UQ6qh2eWAKlAjMIohBUWpkmgWFgWSZ9_DjVQ1Ug3CZ5DEpu4cmxuruI-ZsgRe/exec\"\n# If you get CORS errors on save, replace GS_ENDPOINT with a proxied URL, e.g.:\n# GS_ENDPOINT <- \"https://cors.isomorphic-git.org/https://script.google.com/macros/s/AKfycbyKEc-UQ6qh2eWAKlAjMIohBUWpkmgWFgWSZ9_DjVQ1Ug3CZ5DEpu4cmxuruI-ZsgRe/exec\"\n\n# ---- HELPERS ----\n`%||%` <- function(x, y) if (is.null(x)) y else x\nas_int <- function(x) suppressWarnings(as.integer(x))\n\nget_col <- function(df, col, default = NA_character_) {\n  if (col %in% names(df)) {\n    v <- df[[col]]\n    if (is.list(v)) v <- sapply(v, function(x) paste(x, collapse = \"; \"))\n    if (is.factor(v)) v <- as.character(v)\n    v\n  } else {\n    rep(default, nrow(df))\n  }\n}\n\nsafe_year <- function(x) {\n  suppressWarnings({\n    d <- parse_date_time(x, orders = c(\"ymd\", \"dmy\", \"mdy\", \"Ymd\", \"BdY\", \"dbY\"))\n  })\n  y <- year(d)\n  y[is.na(y)] <- suppressWarnings(as.integer(x[is.na(y)]))\n  y\n}\n\n# ---- LOAD DATA (from GitHub raw URL) ----\nload_source_data <- function(file_type, url) {\n  tf <- tempfile(fileext = if (file_type == \"overton\") \".csv\" else \".txt\")\n  webr::fetch(url, tf)  # GET via webR\n  txt <- readr::read_file(tf)\n  \n  if (file_type == \"overton\") {\n    readr::read_csv(txt, show_col_types = FALSE)\n  } else {\n    # Auto-detect delimiter (tab/semicolon/comma)\n    delim <- if (grepl(\"\\t\", txt)) \"\\t\" else if (grepl(\";\", txt)) \";\" else \",\"\n    readr::read_delim(txt, delim = delim, show_col_types = FALSE, quote = \"\")\n  }\n}\n\n# ---- ADAPTERS ----\nadapt_overton <- function(df) {\n  tibble(\n    source    = \"Overton\",\n    raw_id    = get_col(df, \"Overton id\"),\n    authors   = get_col(df, \"Policy authors\"),\n    year      = safe_year(get_col(df, \"Published_on\")),\n    title     = get_col(df, \"Title\"),\n    journal   = NA_character_,\n    publisher = get_col(df, \"Source title\"),\n    volume    = NA_character_,\n    issue     = NA_character_,\n    pages     = NA_character_,\n    doi       = NA_character_,\n    url       = get_col(df, \"Document URL\"),\n    abstract  = NA_character_\n  )\n}\n\nadapt_scientific <- function(df) {\n  BP <- get_col(df, \"BP\")\n  EP <- get_col(df, \"EP\")\n  pages <- ifelse(!is.na(BP) & !is.na(EP), paste0(BP, \"-\", EP), NA_character_)\n  VL <- get_col(df, \"VL\")\n  IS <- get_col(df, \"IS\")\n  PY <- get_col(df, \"PY\")\n  DI <- get_col(df, \"DI\")\n  DL <- get_col(df, \"DL\")\n  tibble(\n    source    = \"Web of Science\",\n    raw_id    = get_col(df, \"UT\"),\n    authors   = get_col(df, \"AU\"),\n    year      = suppressWarnings(as.integer(PY)),\n    title     = get_col(df, \"TI\"),\n    journal   = get_col(df, \"SO\"),\n    publisher = NA_character_,\n    volume    = as.character(VL),\n    issue     = IS,\n    pages     = pages,\n    doi       = DI,\n    url       = DL,\n    abstract  = get_col(df, \"AB\")\n  )\n}\n\n# ---- RESULTS SCHEMA ----\nexpected_cols <- c(\n  \"title\",\"authors\",\"year\",\"included\",\"exclusion_reason\",\n  \"literature_type\",\"scale_governance\",\n  \"decision_type\",\"policy_stage\",\"participation_level\",\"methods_used\",\n  \"challenges\",\"other_benefits\",\"method_notes\",\n  paste0(\"method_group_\", 1:7)\n)\n\n# ---- GOOGLE SHEET API HELPERS (WebR-friendly) ----\nsheet_get <- function() {\n  tf <- tempfile(fileext = \".json\")\n  ok <- tryCatch({ webr::fetch(GS_ENDPOINT, tf); TRUE }, error = function(e) FALSE)\n  if (!ok) {\n    # Return empty tibble with expected columns\n    return(tibble::as_tibble(setNames(rep(list(character()), length(expected_cols)), expected_cols)))\n  }\n  txt <- readr::read_file(tf)\n  dat <- tryCatch(jsonlite::fromJSON(txt, flatten = TRUE), error = function(e) tibble::tibble())\n  if (!is.data.frame(dat)) dat <- tibble::tibble()\n  for (mc in setdiff(expected_cols, names(dat))) dat[[mc]] <- NA_character_\n  dat %>%\n    dplyr::select(dplyr::all_of(expected_cols)) %>%\n    dplyr::mutate(dplyr::across(dplyr::everything(), as.character))\n}\n\n# POST helper: use JavaScript fetch (added in UI) to upsert a row\nsheet_upsert <- function(row_list) {\n  shinyjs::runjs(sprintf(\n    \"gsUpsert(%s, %s);\",\n    jsonlite::toJSON(GS_ENDPOINT, auto_unbox = TRUE),\n    jsonlite::toJSON(row_list, auto_unbox = TRUE)\n  ))\n  invisible(TRUE)\n}\n\n# =========================\n# UI\n# =========================\nui <- fluidPage(\n  useShinyjs(),\n  # JS helper to POST to GS_ENDPOINT and report status back to R\n  tags$script(HTML(\"\n    async function gsUpsert(url, payload) {\n      try {\n        const resp = await fetch(url, {\n          method: 'POST',\n          headers: {'Content-Type': 'application/json'},\n          body: JSON.stringify(payload)\n        });\n        const txt = await resp.text();\n        let obj = {};\n        try { obj = JSON.parse(txt); } catch(e) {}\n        Shiny.setInputValue('gs_save_status', resp.ok ? 'ok' : ('error:' + (obj.message || txt)), {priority: 'event'});\n      } catch (e) {\n        Shiny.setInputValue('gs_save_status', 'error:' + e.message, {priority: 'event'});\n      }\n    }\n  \")),\n  \n  titlePanel(\"WP2 REA Tool\"),\n  \n  tags$style(HTML(\"\n    .two-col .shiny-options-group { column-count: 2; -moz-column-count: 2; -webkit-column-count: 2; }\n    .two-col .checkbox, .two-col .radio { margin-top: 4px; margin-bottom: 4px; }\n  \")),\n  \n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\"record\", \"Select article\", choices = NULL),\n      width = 3\n    ),\n    \n    mainPanel(\n      tabsetPanel(\n        id = \"main_tabs\",\n        \n        tabPanel(\n          \"1. Eligibility & metadata\", value = \"tab1\",\n          h4(\"Citation Info\"),\n          textOutput(\"title_text\"),\n          textOutput(\"authors_text\"),\n          textOutput(\"year_text\"),\n          hr(),\n          radioButtons(\"included\", \"Meets inclusion criteria?\", choices = c(\"Yes\", \"No\"), selected = character(0)),\n          hr(),\n          radioButtons(\"literature_type\", \"Literature type\", choices = c(\"Grey literature\", \"Scientific Literature\", \"Eklipse/BioAgora\"), selected = character(0)),\n          conditionalPanel(\n            condition = \"input.included == 'No'\",\n            textAreaInput(\"exclusion_reason\", \"Reason for exclusion\", rows = 3),\n            actionButton(\"save_entry_tab1\", \"Save Entry (Not Included)\")\n          )\n        ),\n        \n        tabPanel(\n          \"2. Investigation attributes\", value = \"tab2\",\n          div(class = \"two-col\",\n              checkboxGroupInput(\"decision_type\", \"Type of decision / knowledge need (Pullin et al., 2016) [multi-select]\",\n                                 choices = c(\n                                   \"Seeking better understanding of an issue (including predictions and forecasting)\",\n                                   \"Identifying appropriate ways and means of realising certain decisions\",\n                                   \"Improving understanding of possibilities and boundaries for decision-making\"\n                                 )\n              )\n          ),\n          div(class = \"two-col\",\n              checkboxGroupInput(\"policy_stage\", \"Stage of policy cycle [multi-select]\",\n                                 choices = c(\"Agenda-Setting\",\"Policy Formulation\",\"Policy Adoption\",\"Policy Implementation\",\"Policy Evaluation\")\n              )\n          ),\n          div(class = \"two-col\",\n              checkboxGroupInput(\"participation_level\", \"Level of participation [multi-select]\",\n                                 choices = c(\"Inform\", \"Involve\", \"Consult\", \"Collaborate\", \"Empower\")\n              )\n          ),\n          div(class = \"two-col\",\n              checkboxGroupInput(\"scale_governance\", \"Scale or governance level [multi-select]\",\n                                 choices = c(\"Community/Local\",\"Municipal/City\",\"Regional/Subnational\",\"National\",\"Multinational (e.g., EU)\",\"Global\")\n              )\n          )\n        ),\n        \n        tabPanel(\n          \"3. Methods application\", value = \"tab3\",\n          div(class = \"two-col\",\n              checkboxGroupInput(\"methods_used\", \"Methods used [multi-select]\",\n                                 choices = c(\n                                   \"Bayesian Belief Networks\",\"Bow Tie Analysis\",\"Causal Criteria Analysis\",\"Collaborative Adaptive Management\",\n                                   \"Discourse Analysis\",\"Expert Consultation\",\"Focus Group(s)\",\"Fuzzy Cognitive Mapping\",\"Joint Fact-finding\",\n                                   \"Meta-analysis\",\"Multi-criteria Decision Analysis\",\"Multiple Expert Consultation + Delphi Process\",\n                                   \"Participatory Mapping\",\"Nominal Group Technique\",\"Non-systematic Literature Review\",\n                                   \"Qualitative Comparative Analysis\",\"Rapid Evidence Assessment\",\"Scenario Analysis\",\"Scoping Review\",\n                                   \"Solution Scanning\",\"Structured Decision-making\",\"Subject-wide Evidence Synthesis\",\"Systematic Map\",\n                                   \"Systematic Review\",\"Vote Counting\",\"Additional Method used [elaborate]\"\n                                 )\n              )\n          ),\n          hr(),\n          h4(\"Organize methods into sequential groups (simultaneous within group)\"),\n          uiOutput(\"methods_bucket_ui\"),\n          hr(),\n          div(class = \"two-col\",\n              checkboxGroupInput(\"challenges\", \"Challenges [multi-select]\",\n                                 choices = c(\n                                   \"Participation/logistical (time, recruitment)\",\n                                   \"Evidence/expertise (gaps in expertise)\",\n                                   \"Bias/subjectivity (analytical subjectivity, non-systematic evidence base)\",\n                                   \"Synthesis/integration (complexity of combining heterogeneous inputs)\"\n                                 )\n              )\n          ),\n          textAreaInput(\"other_benefits\", \"Other benefits\", rows = 3),\n          textAreaInput(\"method_notes\", \"Method notes / additions\", rows = 4),\n          actionButton(\"save_entry\", \"Save Entry\")\n        )\n      )\n    )\n  )\n)\n\n# =========================\n# SERVER\n# =========================\nserver <- function(input, output, session) {\n  # Load source data from GitHub raw (WebR fetch)\n  raw_data   <- load_source_data(file_type, DATA_URL)\n  records_df <- if (file_type == \"overton\") adapt_overton(raw_data) else adapt_scientific(raw_data)\n  \n  # Load existing results from Google Sheet (WebR fetch of JSON)\n  results_df <- sheet_get()\n  results_rv <- reactiveVal(results_df)\n  \n  safe_equal_str <- function(a, b) { a <- ifelse(is.na(a), \"\", str_trim(a)); b <- ifelse(is.na(b), \"\", str_trim(b)); a == b }\n  safe_equal_int <- function(a, b) { ai <- as_int(a); bi <- as_int(b); (is.na(ai) & is.na(bi)) | (!is.na(ai) & !is.na(bi) & ai == bi) }\n  \n  completion_status <- function(row) {\n    inc <- row$included\n    if (is.na(inc) || inc == \"\") return(\"ðŸŸ  Not complete\")\n    if (inc == \"No\") {\n      reason_ok <- !is.null(row$exclusion_reason) && nzchar(row$exclusion_reason)\n      if (reason_ok) return(\"ðŸŸ¢ Done â€“ not included\")\n      return(\"ðŸŸ  Not complete\")\n    }\n    if (inc == \"Yes\") {\n      req_ok <- all(\n        nzchar(row$literature_type %||% \"\"),\n        nzchar(row$scale_governance %||% \"\"),\n        nzchar(row$decision_type %||% \"\"),\n        nzchar(row$policy_stage %||% \"\"),\n        nzchar(row$participation_level %||% \"\"),\n        nzchar(row$methods_used %||% \"\"),\n        nzchar(row$challenges %||% \"\")\n      )\n      if (req_ok) return(\"ðŸŸ¢ Done\")\n      return(\"ðŸŸ  Not complete\")\n    }\n    \"ðŸŸ  Not complete\"\n  }\n  \n  update_record_choices <- function() {\n    res <- isolate(results_rv())\n    choices <- sapply(seq_len(nrow(records_df)), function(i) {\n      r <- records_df[i, ]\n      if (nrow(res) > 0) {\n        res_row <- res %>% dplyr::filter(safe_equal_str(title, r$title) & safe_equal_int(year, r$year))\n        status <- if (nrow(res_row) == 0) \"ðŸ”´ Not started\" else completion_status(res_row[1, ])\n      } else {\n        status <- \"ðŸ”´ Not started\"\n      }\n      paste0(r$year, \" â€“ \", r$title, \" [\", status, \"]\")\n    })\n    updateSelectInput(session, \"record\", choices = setNames(seq_len(nrow(records_df)), choices))\n  }\n  update_record_choices()\n  \n  current <- reactive({ req(input$record); records_df[as.integer(input$record), ] })\n  \n  output$title_text   <- renderText({ paste(\"Title:\",   current()$title) })\n  output$authors_text <- renderText({ paste(\"Authors:\", current()$authors) })\n  output$year_text    <- renderText({ paste(\"Year:\",    current()$year) })\n  \n  observe({ inc <- input$included; if (is.null(inc) || inc != \"Yes\") updateTabsetPanel(session, \"main_tabs\", selected = \"tab1\") })\n  \n  output$methods_bucket_ui <- renderUI({\n    req(input$methods_used)\n    n_methods <- length(input$methods_used)\n    n_groups  <- min(n_methods, 7)\n    rank_lists <- lapply(seq_len(n_groups), function(i) {\n      add_rank_list(text = paste0(\"Group \", i), labels = NULL, input_id = paste0(\"group_\", i))\n    })\n    do.call(bucket_list, c(\n      list(\n        header = \"Drag methods into sequential groups (simultaneous within group)\",\n        group_name = \"method_groups\",\n        orientation = \"horizontal\",\n        add_rank_list(text = \"Available methods\", labels = input$methods_used, input_id = \"methods_source\")\n      ),\n      rank_lists\n    ))\n  })\n  \n  observe({\n    if (!is.null(input$main_tabs) && input$main_tabs %in% c(\"tab2\", \"tab3\")) {\n      if (is.null(input$included) || input$included != \"Yes\") {\n        showNotification(\"You must mark 'Meets inclusion criteria?' as Yes to proceed.\", type = \"error\")\n        updateTabsetPanel(session, \"main_tabs\", selected = \"tab1\")\n      }\n    }\n  })\n  \n  # Handle upsert status (from JS) and refresh results\n  observeEvent(input$gs_save_status, {\n    status <- input$gs_save_status\n    if (is.null(status)) return()\n    if (identical(status, \"ok\")) {\n      showNotification(\"Saved to Google Sheet.\", type = \"message\")\n      results_rv(sheet_get())\n      update_record_choices()\n    } else {\n      showNotification(paste(\"Save failed:\", status), type = \"error\")\n    }\n  })\n  \n  observeEvent(input$save_entry_tab1, {\n    req(input$included)\n    if (input$included != \"No\") {\n      showNotification(\"Use the Tab 3 Save Entry for included records.\", type = \"warning\"); return(NULL)\n    }\n    if (is.null(input$exclusion_reason) || input$exclusion_reason == \"\") {\n      showNotification(\"Please provide a reason for exclusion.\", type = \"error\"); return(NULL)\n    }\n    \n    row <- list(\n      title = as.character(current()$title),\n      authors = as.character(current()$authors),\n      year = as.character(current()$year),\n      included = \"No\",\n      exclusion_reason = as.character(input$exclusion_reason),\n      literature_type = as.character(input$literature_type %||% \"\"),\n      scale_governance = NA_character_,\n      decision_type = NA_character_,\n      policy_stage = NA_character_,\n      participation_level = NA_character_,\n      methods_used = NA_character_,\n      challenges = NA_character_,\n      other_benefits = NA_character_,\n      method_notes = NA_character_,\n      method_group_1 = NA_character_, method_group_2 = NA_character_, method_group_3 = NA_character_,\n      method_group_4 = NA_character_, method_group_5 = NA_character_, method_group_6 = NA_character_,\n      method_group_7 = NA_character_\n    )\n    sheet_upsert(row)\n  })\n  \n  observeEvent(input$save_entry, {\n    req(input$included)\n    if (input$included != \"Yes\") {\n      showNotification(\"Mark inclusion as 'Yes' to save full methods entry, or save as exclusion in Tab 1.\", type = \"warning\"); return(NULL)\n    }\n    \n    methods_wide <- sapply(1:7, function(i) {\n      g <- input$method_groups[[paste0(\"group_\", i)]]\n      if (is.null(g) || length(g) == 0) return(NA_character_)\n      paste(g, collapse = \"; \")\n    })\n    \n    row <- list(\n      title = as.character(current()$title),\n      authors = as.character(current()$authors),\n      year = as.character(current()$year),\n      included = \"Yes\",\n      exclusion_reason = NA_character_,\n      literature_type = as.character(input$literature_type %||% \"\"),\n      scale_governance = paste(input$scale_governance %||% character(), collapse = \"; \"),\n      decision_type = paste(input$decision_type %||% character(), collapse = \"; \"),\n      policy_stage = paste(input$policy_stage %||% character(), collapse = \"; \"),\n      participation_level = paste(input$participation_level %||% character(), collapse = \"; \"),\n      methods_used = paste(input$methods_used %||% character(), collapse = \"; \"),\n      challenges = paste(input$challenges %||% character(), collapse = \"; \"),\n      other_benefits = as.character(input$other_benefits),\n      method_notes = as.character(input$method_notes),\n      method_group_1 = methods_wide[1], method_group_2 = methods_wide[2], method_group_3 = methods_wide[3],\n      method_group_4 = methods_wide[4], method_group_5 = methods_wide[5], method_group_6 = methods_wide[6],\n      method_group_7 = methods_wide[7]\n    )\n    sheet_upsert(row)\n  })\n}\n\nshinyApp(ui, server)","type":"text"},{"name":"webr-packages.txt","content":"shiny\nshinyjs\nsortable\nreadr\ndplyr\nlubridate\ntibble\nstringr\njsonlite\nwebr\n","type":"text"}]
